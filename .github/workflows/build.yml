name: Build and Release

# Optimized CI/CD workflow with intelligent caching
#
# Trigger: Automatic on every push to main + manual workflow dispatch (via GitHub Actions UI)
#
# Architecture:
#   setup â†’ build-android â†˜
#                          â†’ create-release
#   setup â†’ build-ios     â†—
#
# Key features:
# - Runs on every push to main and can also be triggered manually
# - Separate setup job for dependencies (cached intelligently)
# - Parallel Android/iOS builds after setup
# - Caches: Flutter SDK, Pub, Gradle, CocoaPods, llama.cpp, generated code
# - Cache invalidation: automatic based on lock files and version files
# - Saves ~90% time on subsequent builds
# - Creates GitHub release with APK, AAB, and iOS build

env:
  FLUTTER_VERSION: '3.19.0'
  JAVA_VERSION: '17'
  GRADLE_VERSION: '8.2.1'
  ANDROID_NDK_VERSION: '25.1.8937393'
  LANG: en_US.UTF-8

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  ################################################################################
  # SETUP - Install and cache all dependencies and tools
  ################################################################################
  setup:
    name: Setup Dependencies & Tools
    runs-on: self-hosted

    outputs:
      has-generated-code: ${{ steps.detect-generated.outputs.present }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Self-hosted runners are persistent: prefer using existing Flutter SDK on disk
      # and only update when FLUTTER_VERSION changes.
      - name: Ensure Flutter installed (reuse runner state)
        run: |
          if [ ! -d "$HOME/flutter/.git" ]; then
            git clone https://github.com/flutter/flutter.git -b stable $HOME/flutter
          fi
          cd $HOME/flutter
          git fetch --tags
          git checkout ${{ env.FLUTTER_VERSION }}

      # Add Flutter to PATH
      - name: Add Flutter to PATH
        run: |
          echo "$HOME/flutter/bin" >> $GITHUB_PATH
          echo "$HOME/.pub-cache/bin" >> $GITHUB_PATH

      # Run flutter doctor
      - name: Flutter Doctor
        run: flutter doctor -v

      # Get Flutter dependencies
      - name: Get Flutter dependencies
        run: flutter pub get

      # Code generation (kept as a setup step so Android/iOS jobs don't duplicate work)
      - name: Run code generation
        run: flutter pub run build_runner build --delete-conflicting-outputs

      - name: Detect generated code
        id: detect-generated
        run: |
          if find . -type f \( -name "*.g.dart" -o -name "*.freezed.dart" -o -name "*.config.dart" \) -print -quit | grep -q .; then
            echo "present=true" >> $GITHUB_OUTPUT
          else
            echo "present=false" >> $GITHUB_OUTPUT
          fi

      # Upload generated code as artifact for build jobs
      - name: Upload generated code
        if: steps.detect-generated.outputs.present == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: generated-code
          path: |
            **/*.g.dart
            **/*.freezed.dart
            **/*.config.dart
          if-no-files-found: warn
          retention-days: 1

      # Analyze code
      - name: Analyze code
        run: flutter analyze

      # Run tests
      - name: Run tests
        run: flutter test

  ################################################################################
  # BUILD ANDROID - Build APK/AAB with cached dependencies
  ################################################################################
  build-android:
    name: Build Android APK/AAB
    runs-on: self-hosted
    needs: setup

    # Self-hosted runners are persistent; isolate Gradle state per Java version to avoid
    # cache contamination when the machine default JDK changes (e.g. JDK 21 â†’ classfile 65).
    env:
      GRADLE_OPTS: -Dorg.gradle.daemon=false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Add Flutter to PATH
      - name: Add Flutter to PATH
        run: |
          echo "$HOME/flutter/bin" >> $GITHUB_PATH
          echo "$HOME/.pub-cache/bin" >> $GITHUB_PATH

      - name: Verify Flutter on runner
        run: |
          if [ ! -x "$HOME/flutter/bin/flutter" ]; then
            echo "âŒ Flutter not found at $HOME/flutter/bin/flutter"
            exit 1
          fi

      # Download generated code from setup job
      - name: Download generated code
        if: needs.setup.outputs.has-generated-code == 'true'
        uses: actions/download-artifact@v4
        with:
          name: generated-code
          path: .

      # Setup Java with Gradle caching
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: ${{ env.JAVA_VERSION }}

      - name: Capture Java home (lock for later steps)
        run: |
          # Some Actions may modify JAVA_HOME; keep the JDK selected above for Flutter/Gradle.
          echo "JDK_HOME=$JAVA_HOME" >> "$GITHUB_ENV"

      - name: Show Java version
        run: java -version

      - name: Configure isolated Gradle cache
        run: |
          # Use a per-run Gradle user home to avoid reusing compiled script caches that may have
          # been produced by a different JDK on the persistent self-hosted runner.
          GRADLE_USER_HOME_DIR="${RUNNER_TEMP}/gradle-${{ github.run_id }}-${{ github.run_attempt }}-jdk${{ env.JAVA_VERSION }}"
          echo "GRADLE_USER_HOME=$GRADLE_USER_HOME_DIR" >> "$GITHUB_ENV"

          # Also force Gradle to use the same JDK we selected above (self-hosted runners may have
          # a different system default Java).
          echo "GRADLE_OPTS=$GRADLE_OPTS -Dorg.gradle.java.home=$JAVA_HOME" >> "$GITHUB_ENV"

          echo "Using GRADLE_USER_HOME=$GRADLE_USER_HOME_DIR"
          echo "Using org.gradle.java.home=$JAVA_HOME"
          mkdir -p "$GRADLE_USER_HOME_DIR"
          # Fix: self-hosted runner may reuse compiled script caches created under a different JDK
          # (e.g. JDK 21 -> classfile major 65), which then fails under Java 17.
          rm -rf "$GRADLE_USER_HOME_DIR/caches" "$GRADLE_USER_HOME_DIR/daemon" || true

      - name: Setup Gradle (pin version)
        run: |
          GRADLE_VERSION="${{ env.GRADLE_VERSION }}"
          GRADLE_DIST_DIR="$RUNNER_TEMP/gradle-dist-$GRADLE_VERSION"
          GRADLE_ZIP="$RUNNER_TEMP/gradle-$GRADLE_VERSION-bin.zip"
          GRADLE_BIN_DIR="$GRADLE_DIST_DIR/gradle-$GRADLE_VERSION/bin"

          if [ ! -d "$GRADLE_DIST_DIR/gradle-$GRADLE_VERSION" ]; then
            echo "Downloading Gradle $GRADLE_VERSION..."
            curl -sSL -o "$GRADLE_ZIP" "https://services.gradle.org/distributions/gradle-$GRADLE_VERSION-bin.zip"
            mkdir -p "$GRADLE_DIST_DIR"
            unzip -q "$GRADLE_ZIP" -d "$GRADLE_DIST_DIR"
          fi

          # NOTE: $GITHUB_PATH affects subsequent steps only. Export PATH here so `gradle` is
          # available in this step as well.
          echo "$GRADLE_BIN_DIR" >> $GITHUB_PATH
          export PATH="$GRADLE_BIN_DIR:$PATH"
          gradle -v

      - name: Verify Java used for Gradle
        run: |
          echo "JAVA_HOME=$JAVA_HOME"
          which java || true
          java -version

      - name: Verify Java before Flutter build
        run: |
          echo "JAVA_HOME(before)=$JAVA_HOME"
          echo "JDK_HOME=$JDK_HOME"
          echo "java(before)=$(which java || true)"
          java -version
          flutter doctor -v || true

      # Ensure Android SDK + sdkmanager are available (self-hosted runner might not export env vars)
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # Fix conflicting Android environment variables
      - name: Fix Android env vars (unset ANDROID_SDK_HOME, keep only ANDROID_USER_HOME)
        run: |
          # AGP fails if BOTH ANDROID_SDK_HOME and ANDROID_USER_HOME are set, even to the
          # same path. The fix is to unset ANDROID_SDK_HOME completely and use only
          # ANDROID_USER_HOME (the recommended modern variable).
          # See: https://developer.android.com/tools/variables
          #
          # We cannot truly "unset" an env var from $GITHUB_ENV, but we can override it to
          # empty in the current step and ensure subsequent steps don't see it by NOT
          # exporting it. However, the runner's shell profile may re-export it.
          #
          # The cleanest fix: unset it in the shell before running Gradle.
          # We'll set a marker variable and handle it in the Build APK step.
          ANDROID_PREFS_DIR="$HOME/.android"
          mkdir -p "$ANDROID_PREFS_DIR"
          echo "ANDROID_USER_HOME=$ANDROID_PREFS_DIR" >> $GITHUB_ENV
          # Do NOT set ANDROID_SDK_HOME here. We'll unset it in the build step.

      - name: Ensure Android NDK installed
        run: |
          sdkmanager --install "ndk;${{ env.ANDROID_NDK_VERSION }}"
          yes | sdkmanager --licenses > /dev/null
          echo "ANDROID_NDK_HOME=$ANDROID_SDK_ROOT/ndk/${{ env.ANDROID_NDK_VERSION }}" >> $GITHUB_ENV
          echo "ANDROID_NDK=$ANDROID_SDK_ROOT/ndk/${{ env.ANDROID_NDK_VERSION }}" >> $GITHUB_ENV

      # Ensure Android resources exist (mipmap, styles, etc.)
      - name: Ensure Android project resources exist
        run: |
          # Check if required Android resources are missing
          if [ ! -d "android/app/src/main/res" ]; then
            echo "âš ï¸  Android resources missing (res directory). Regenerating via flutter create..."

            PROJECT_NAME="$(awk -F': *' '/^name:/{print $2; exit}' pubspec.yaml)"
            if [ -z "$PROJECT_NAME" ]; then
              PROJECT_NAME="cruises_mobile"
            fi

            # Preserve existing files that flutter create might overwrite
            if [ -f "android/app/build.gradle" ]; then
              cp "android/app/build.gradle" "$RUNNER_TEMP/android_app_build.gradle.bak"
            fi
            if [ -f "android/app/src/main/AndroidManifest.xml" ]; then
              cp "android/app/src/main/AndroidManifest.xml" "$RUNNER_TEMP/AndroidManifest.xml.bak"
            fi
            if [ -f "android/gradle/wrapper/gradle-wrapper.properties" ]; then
              cp "android/gradle/wrapper/gradle-wrapper.properties" "$RUNNER_TEMP/gradle-wrapper.properties.bak"
            fi
            if [ -f "android/build.gradle" ]; then
              cp "android/build.gradle" "$RUNNER_TEMP/android_build.gradle.bak"
            fi
            if [ -f "android/settings.gradle" ]; then
              cp "android/settings.gradle" "$RUNNER_TEMP/android_settings.gradle.bak"
            fi

            # Generate Android project files
            flutter create --platforms=android --project-name "$PROJECT_NAME" . || true

            # Restore preserved gradle files (flutter create may downgrade Gradle version)
            if [ -f "$RUNNER_TEMP/android_build.gradle.bak" ]; then
              cp "$RUNNER_TEMP/android_build.gradle.bak" "android/build.gradle"
              echo "âœ… Restored android/build.gradle"
            fi
            if [ -f "$RUNNER_TEMP/android_settings.gradle.bak" ]; then
              cp "$RUNNER_TEMP/android_settings.gradle.bak" "android/settings.gradle"
              echo "âœ… Restored android/settings.gradle"
            fi

            echo "âœ… Android resources generated"
          fi

          # Always ensure Gradle 8.0+ is configured (required by AGP 8.x)
          GRADLE_WRAPPER_FILE="android/gradle/wrapper/gradle-wrapper.properties"
          if [ -f "$GRADLE_WRAPPER_FILE" ]; then
            CURRENT_GRADLE=$(grep distributionUrl "$GRADLE_WRAPPER_FILE" | grep -oE 'gradle-[0-9.]+' | head -1)
            echo "Current Gradle version: $CURRENT_GRADLE"

            # Check if version is less than 8.0
            if echo "$CURRENT_GRADLE" | grep -qE 'gradle-[0-7]\.'; then
              echo "âš ï¸  Gradle version is below 8.0, upgrading..."
              sed -i.bak 's|distributionUrl=.*|distributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-all.zip|' "$GRADLE_WRAPPER_FILE"
              echo "âœ… Updated gradle-wrapper.properties to Gradle 8.0"
              cat "$GRADLE_WRAPPER_FILE"
            fi
          else
            echo "âŒ gradle-wrapper.properties not found at $GRADLE_WRAPPER_FILE"
            ls -la android/gradle/wrapper/ || true
          fi

          # Verify resources exist
          if [ ! -d "android/app/src/main/res/mipmap-hdpi" ]; then
            echo "âŒ Android mipmap resources still missing"
            ls -la android/app/src/main/ || true
            exit 1
          fi
          if [ ! -f "android/app/src/main/res/values/styles.xml" ]; then
            echo "âŒ Android styles.xml still missing"
            ls -la android/app/src/main/res/ || true
            exit 1
          fi
          echo "âœ… Android resources verified"
          ls -la android/app/src/main/res/

      - name: Ensure CMake available (required by llama.cpp build scripts)
        run: |
          if command -v cmake >/dev/null 2>&1; then
            echo "âœ… CMake already available: $(cmake --version | head -n 1)"
            exit 0
          fi

          echo "CMake not found; installing via Android SDK..."
          sdkmanager --install "cmake;3.22.1"
          yes | sdkmanager --licenses > /dev/null

          CMAKE_BIN_DIR="$ANDROID_SDK_ROOT/cmake/3.22.1/bin"
          "$CMAKE_BIN_DIR/cmake" --version
          echo "$CMAKE_BIN_DIR" >> $GITHUB_PATH

      # Build (or reuse local runner cache) llama.cpp for Android
      - name: Ensure llama.cpp Android library
        run: |
          chmod +x scripts/build-llama-android.sh
          bash scripts/build-llama-android.sh

        # NOTE: Do not override ANDROID_NDK_HOME here.
        # On self-hosted runners it's usually configured as a machine-level env var,
        # and setting it via `${{ env.ANDROID_NDK_HOME }}` can unintentionally blank it.

      # Verify llama.cpp library exists
      - name: Verify llama.cpp library
        run: |
          if [ ! -f "android/app/src/main/jniLibs/arm64-v8a/libllama.so" ]; then
            echo "âŒ Error: libllama.so not found!"
            exit 1
          fi
          echo "âœ… llama.cpp library found"
          ls -lh android/app/src/main/jniLibs/*/libllama.so

      # Get dependencies (should be fast due to cache)
      - name: Get dependencies
        run: flutter pub get

      # The llama_cpp_dart package from pub.dev does NOT include the llama.cpp submodule.
      # We need to clone it into the pub-cache directory for the native CMake build to work.
      # CMakeLists.txt is in src/ directory, so llama.cpp must be at src/llama.cpp
      - name: Clone llama.cpp into llama_cpp_dart package
        run: |
          # Read version from our version file
          LLAMA_VERSION=$(grep -v '^[[:space:]]*#' scripts/llama-version.txt | grep -v '^[[:space:]]*$' | head -n 1)
          echo "llama.cpp version: $LLAMA_VERSION"

          # Find the llama_cpp_dart package directory
          PUB_CACHE="${PUB_CACHE:-$HOME/.pub-cache}"
          LLAMA_PKG_DIR=$(find "$PUB_CACHE/hosted" -maxdepth 2 -type d -name "llama_cpp_dart-*" | head -n 1)

          if [ -z "$LLAMA_PKG_DIR" ]; then
            echo "âŒ Error: llama_cpp_dart package not found in pub cache"
            exit 1
          fi
          echo "Found llama_cpp_dart at: $LLAMA_PKG_DIR"

          # Clone llama.cpp into the src subdirectory of the package
          # (CMakeLists.txt is in src/ and references ./llama.cpp relative to itself)
          LLAMA_CPP_DIR="$LLAMA_PKG_DIR/src/llama.cpp"
          if [ ! -d "$LLAMA_CPP_DIR" ]; then
            echo "Cloning llama.cpp into $LLAMA_CPP_DIR..."
            git clone --depth 1 --branch "$LLAMA_VERSION" https://github.com/ggml-org/llama.cpp "$LLAMA_CPP_DIR" || \
            git clone https://github.com/ggml-org/llama.cpp "$LLAMA_CPP_DIR"

            if [ -d "$LLAMA_CPP_DIR" ]; then
              cd "$LLAMA_CPP_DIR"
              git fetch --tags origin
              git checkout "$LLAMA_VERSION" || echo "Warning: Could not checkout $LLAMA_VERSION, using default branch"
            fi
          else
            echo "âœ… llama.cpp already exists at $LLAMA_CPP_DIR"
          fi

          # Verify
          if [ -d "$LLAMA_CPP_DIR" ]; then
            echo "âœ… llama.cpp cloned successfully"
            ls -la "$LLAMA_CPP_DIR" | head -10
          else
            echo "âŒ Error: Failed to clone llama.cpp"
            exit 1
          fi

      # Build APK
      - name: Build APK
        run: |
          # Force Flutter/Gradle to use the JDK installed by actions/setup-java.
          export JAVA_HOME="$JDK_HOME"
          export PATH="$JAVA_HOME/bin:$PATH"
          # Unset ANDROID_SDK_HOME to avoid AGP conflict with ANDROID_USER_HOME
          unset ANDROID_SDK_HOME
          echo "JAVA_HOME(used)=$JAVA_HOME"
          echo "ANDROID_USER_HOME=$ANDROID_USER_HOME"
          echo "ANDROID_SDK_HOME is unset"
          java -version
          flutter build apk --release --verbose

      # Build App Bundle
      - name: Build App Bundle
        run: |
          export JAVA_HOME="$JDK_HOME"
          export PATH="$JAVA_HOME/bin:$PATH"
          # Unset ANDROID_SDK_HOME to avoid AGP conflict with ANDROID_USER_HOME
          unset ANDROID_SDK_HOME
          echo "JAVA_HOME(used)=$JAVA_HOME"
          java -version
          flutter build appbundle --release --verbose

      # Upload APK artifact
      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-apk
          path: build/app/outputs/flutter-apk/app-release.apk
          retention-days: 30

      # Upload AAB artifact
      - name: Upload AAB artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-aab
          path: build/app/outputs/bundle/release/app-release.aab
          retention-days: 30

  ################################################################################
  # BUILD iOS - Build APP with cached dependencies
  ################################################################################
  build-ios:
    name: Build iOS APP
    runs-on: self-hosted
    needs: setup

    # ruby/setup-ruby expects a writable toolcache directory.

    # On self-hosted macOS runners the hosted default (/Users/runner/hostedtoolcache) may not exist.
    # NOTE: ruby/setup-ruby prebuilt Rubies are built for the default toolcache path on macOS
    # (/Users/runner/hostedtoolcache) and cannot be relocated.
    env:
      RUNNER_TOOL_CACHE: /Users/runner/hostedtoolcache
      AGENT_TOOLSDIRECTORY: /Users/runner/hostedtoolcache

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Add Flutter to PATH
      - name: Add Flutter to PATH
        run: |
          echo "$HOME/flutter/bin" >> $GITHUB_PATH
          echo "$HOME/.pub-cache/bin" >> $GITHUB_PATH

      - name: Verify Flutter on runner
        run: |
          if [ ! -x "$HOME/flutter/bin/flutter" ]; then
            echo "âŒ Flutter not found at $HOME/flutter/bin/flutter"
            exit 1
          fi

      # Download generated code from setup job
      - name: Download generated code
        if: needs.setup.outputs.has-generated-code == 'true'
        uses: actions/download-artifact@v4
        with:
          name: generated-code
          path: .

      - name: Ensure iOS project files exist (Podfile/Xcode project)
        run: |
          # Some repos may not check in the full iOS scaffold. CocoaPods requires ios/Podfile,
          # and Flutter iOS builds require ios/Runner.xcodeproj.
          #
          # IMPORTANT: Podfile is generated by `flutter pub get`, NOT by `flutter create --no-pub`.
          # So we need to run pub get after create, or not use --no-pub.

          if [ ! -d "ios/Runner.xcodeproj" ]; then
            echo "âš ï¸  iOS project scaffold missing (Runner.xcodeproj). Regenerating via flutter create..."

            # Ensure flutter create uses a valid Dart package name (dir name may contain '-').
            PROJECT_NAME="$(awk -F': *' '/^name:/{print $2; exit}' pubspec.yaml)"
            if [ -z "$PROJECT_NAME" ]; then
              PROJECT_NAME="cruises_mobile"
            fi

            # Preserve any custom Info.plist committed in the repo.
            if [ -f "ios/Runner/Info.plist" ]; then
              cp "ios/Runner/Info.plist" "$RUNNER_TEMP/Info.plist.bak"
            fi

            # Preserve llama xcframework if it already exists (avoid losing it if flutter create overwrites ios/).
            if [ -d "ios/Frameworks/llama.xcframework" ]; then
              rm -rf "$RUNNER_TEMP/llama.xcframework.bak"
              cp -R "ios/Frameworks/llama.xcframework" "$RUNNER_TEMP/llama.xcframework.bak"
            fi

            # flutter create WITHOUT --no-pub to generate Podfile
            flutter create --platforms=ios --project-name "$PROJECT_NAME" . || true
            # If first attempt didn't create files, try with --overwrite
            if [ ! -d "ios/Runner.xcodeproj" ]; then
              flutter create --platforms=ios --project-name "$PROJECT_NAME" --overwrite . || true
            fi

            if [ -f "$RUNNER_TEMP/Info.plist.bak" ]; then
              cp "$RUNNER_TEMP/Info.plist.bak" "ios/Runner/Info.plist"
            fi

            if [ -d "$RUNNER_TEMP/llama.xcframework.bak" ]; then
              mkdir -p ios/Frameworks
              rm -rf ios/Frameworks/llama.xcframework
              cp -R "$RUNNER_TEMP/llama.xcframework.bak" ios/Frameworks/llama.xcframework
            fi
          fi

          # If Podfile still missing but Runner.xcodeproj exists, run pub get to generate it
          if [ ! -f "ios/Podfile" ] && [ -d "ios/Runner.xcodeproj" ]; then
            echo "âš ï¸  Podfile missing, running flutter pub get to generate it..."
            flutter pub get
          fi

          # Final check - fail if required files are still missing
          if [ ! -f "ios/Podfile" ]; then
            echo "âŒ ios/Podfile still missing after flutter create and pub get"
            exit 1
          fi
          if [ ! -d "ios/Runner.xcodeproj" ]; then
            echo "âŒ ios/Runner.xcodeproj still missing after flutter create"
            exit 1
          fi
          echo "âœ… iOS project scaffold is ready"
          ls -la ios/Podfile ios/Runner.xcodeproj

      - name: Ensure CMake available (required by llama.cpp build scripts)
        run: |
          if command -v cmake >/dev/null 2>&1; then
            echo "âœ… CMake already available: $(cmake --version | head -n 1)"
            exit 0
          fi

          if command -v brew >/dev/null 2>&1; then
            echo "CMake not found; installing via Homebrew..."
            HOMEBREW_NO_AUTO_UPDATE=1 brew install cmake
            cmake --version
            exit 0
          fi

          echo "âŒ Error: cmake is required but was not found, and Homebrew is unavailable on this runner."
          echo "Install CMake on the self-hosted runner, or add a workflow step to provide it."
          exit 1


      # Build (or reuse local runner cache) llama.cpp for iOS
      - name: Ensure llama.cpp for iOS
        run: |
          chmod +x scripts/build-llama-ios.sh
          bash scripts/build-llama-ios.sh

      # Verify llama.cpp framework exists
      - name: Verify llama.cpp framework
        run: |
          if [ ! -d "ios/Frameworks/llama.xcframework" ]; then
            echo "âŒ Error: llama.xcframework not found!"
            exit 1
          fi
          echo "âœ… llama.cpp framework found"
          ls -lh ios/Frameworks/

      # Get dependencies (should be fast due to cache)
      - name: Get dependencies
        run: flutter pub get

      # The llama_cpp_dart package from pub.dev does NOT include the llama.cpp submodule.
      # We need to clone it into the pub-cache directory for the native build to work.
      # CMakeLists.txt is in src/ directory, so llama.cpp must be at src/llama.cpp
      - name: Clone llama.cpp into llama_cpp_dart package
        run: |
          # Read version from our version file
          LLAMA_VERSION=$(grep -v '^[[:space:]]*#' scripts/llama-version.txt | grep -v '^[[:space:]]*$' | head -n 1)
          echo "llama.cpp version: $LLAMA_VERSION"

          # Find the llama_cpp_dart package directory
          PUB_CACHE="${PUB_CACHE:-$HOME/.pub-cache}"
          LLAMA_PKG_DIR=$(find "$PUB_CACHE/hosted" -maxdepth 2 -type d -name "llama_cpp_dart-*" | head -n 1)

          if [ -z "$LLAMA_PKG_DIR" ]; then
            echo "âŒ Error: llama_cpp_dart package not found in pub cache"
            exit 1
          fi
          echo "Found llama_cpp_dart at: $LLAMA_PKG_DIR"

          # Clone llama.cpp into the src subdirectory of the package
          # (CMakeLists.txt is in src/ and references ./llama.cpp relative to itself)
          LLAMA_CPP_DIR="$LLAMA_PKG_DIR/src/llama.cpp"
          if [ ! -d "$LLAMA_CPP_DIR" ]; then
            echo "Cloning llama.cpp into $LLAMA_CPP_DIR..."
            git clone --depth 1 --branch "$LLAMA_VERSION" https://github.com/ggml-org/llama.cpp "$LLAMA_CPP_DIR" || \
            git clone https://github.com/ggml-org/llama.cpp "$LLAMA_CPP_DIR"

            if [ -d "$LLAMA_CPP_DIR" ]; then
              cd "$LLAMA_CPP_DIR"
              git fetch --tags origin
              git checkout "$LLAMA_VERSION" || echo "Warning: Could not checkout $LLAMA_VERSION, using default branch"
            fi
          else
            echo "âœ… llama.cpp already exists at $LLAMA_CPP_DIR"
          fi

          # Verify
          if [ -d "$LLAMA_CPP_DIR" ]; then
            echo "âœ… llama.cpp cloned successfully"
            ls -la "$LLAMA_CPP_DIR" | head -10
          else
            echo "âŒ Error: Failed to clone llama.cpp"
            exit 1
          fi

      - name: Detect CocoaPods
        id: detect_pod
        run: |
          if command -v pod >/dev/null 2>&1; then
            echo "present=true" >> "$GITHUB_OUTPUT"
          else
            echo "present=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure Ruby toolcache dir exists (self-hosted)
        if: steps.detect_pod.outputs.present != 'true'
        run: |
          echo "RUNNER_TOOL_CACHE=$RUNNER_TOOL_CACHE"
          echo "AGENT_TOOLSDIRECTORY=$AGENT_TOOLSDIRECTORY"
          TOOLCACHE="$RUNNER_TOOL_CACHE"

          if [ -d "$TOOLCACHE" ] && [ -w "$TOOLCACHE" ]; then
            echo "âœ… Toolcache is writable: $TOOLCACHE"
            exit 0
          fi

          echo "âš ï¸  Toolcache is missing or not writable: $TOOLCACHE"
          echo "Attempting to create it (requires sudo on most self-hosted runners)..."

          if command -v sudo >/dev/null 2>&1; then
            sudo mkdir -p "$TOOLCACHE"
            sudo chown -R "$(id -un)":"$(id -gn)" /Users/runner
          else
            echo "âŒ sudo is not available. Please create $TOOLCACHE and make it writable for the runner user."
            exit 1
          fi

          if [ ! -w "$TOOLCACHE" ]; then
            echo "âŒ Toolcache is still not writable after attempting to fix permissions: $TOOLCACHE"
            exit 1
          fi
          echo "âœ… Toolcache prepared: $TOOLCACHE"

      - name: Setup Ruby (for CocoaPods)
        if: steps.detect_pod.outputs.present != 'true'
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'

      - name: Ensure libyaml for Ruby (psych) on self-hosted runner
        if: steps.detect_pod.outputs.present != 'true'
        run: |
          # Ruby's psych extension depends on libyaml. The prebuilt Ruby from ruby/setup-ruby
          # expects Homebrew libyaml at /opt/homebrew/opt/libyaml on Apple Silicon.
          if command -v brew >/dev/null 2>&1; then
            export HOMEBREW_NO_AUTO_UPDATE=1
            if ! brew list libyaml >/dev/null 2>&1; then
              echo "Installing libyaml via Homebrew..."
              brew install libyaml
            else
              echo "âœ… libyaml already installed"
            fi

            YAML_PREFIX="$(brew --prefix libyaml || true)"
            echo "libyaml prefix: ${YAML_PREFIX}"
            ls -l "${YAML_PREFIX}/lib/libyaml-0.2.dylib" || true
          else
            echo "âŒ Homebrew (brew) not found. Install libyaml on the self-hosted runner so Ruby can load psych.bundle."
            exit 1
          fi

      - name: Ensure OpenSSL for Ruby (RubyGems HTTPS)
        if: steps.detect_pod.outputs.present != 'true'
        run: |
          # RubyGems needs Ruby's OpenSSL extension for HTTPS downloads.
          # On self-hosted Apple Silicon runners the prebuilt Ruby can dynamically link to
          # Homebrew OpenSSL libraries.
          if command -v brew >/dev/null 2>&1; then
            export HOMEBREW_NO_AUTO_UPDATE=1

            if ! brew list openssl@3 >/dev/null 2>&1; then
              echo "Installing openssl@3 via Homebrew..."
              brew install openssl@3
            else
              echo "âœ… openssl@3 already installed"
            fi

            OPENSSL_PREFIX="$(brew --prefix openssl@3 || true)"
            echo "openssl@3 prefix: ${OPENSSL_PREFIX}"
            ls -l "${OPENSSL_PREFIX}/lib/libssl.3.dylib" || true
            ls -l "${OPENSSL_PREFIX}/lib/libcrypto.3.dylib" || true

            # Sanity-check that the selected Ruby can load OpenSSL.
            ruby -ropenssl -e 'puts OpenSSL::OPENSSL_VERSION'
          else
            echo "âŒ Homebrew (brew) not found. Install OpenSSL (openssl@3) on the self-hosted runner so gem can download over HTTPS."
            exit 1
          fi

      # Precache iOS artifacts (required before pod install)
      - name: Flutter precache iOS
        run: |
          # pod install requires Flutter.xcframework to exist.
          # flutter precache --ios downloads and extracts it.
          echo "Running flutter precache --ios..."
          flutter precache --ios
          # Verify the framework exists
          if [ -d "$HOME/flutter/bin/cache/artifacts/engine/ios/Flutter.xcframework" ]; then
            echo "âœ… Flutter.xcframework found"
          else
            # Try alternative location
            FLUTTER_ROOT="$(dirname "$(dirname "$(which flutter)")")"
            echo "Flutter root: $FLUTTER_ROOT"
            ls -la "$FLUTTER_ROOT/bin/cache/artifacts/engine/ios/" || true
          fi

      # Install CocoaPods dependencies
      - name: Install CocoaPods dependencies
        run: |
          if ! command -v pod >/dev/null 2>&1; then
            echo "âš ï¸  CocoaPods (pod) not found. Installing to user gem dir..."
            if ! command -v gem >/dev/null 2>&1; then
              echo "âŒ RubyGems (gem) not found on runner; cannot install CocoaPods"
              exit 1
            fi
            # Use a modern Ruby (via ruby/setup-ruby) to avoid ffi/CocoaPods install failures on
            # older system Rubies on persistent self-hosted runners.
            gem install --user-install cocoapods -N
            POD_BIN_DIR="$(ruby -e 'print Gem.user_dir')/bin"
            echo "$POD_BIN_DIR" >> "$GITHUB_PATH"
            export PATH="$POD_BIN_DIR:$PATH"
          fi
          pod --version
          cd ios
          pod install

      # Build iOS for Simulator (Debug mode for simulator compatibility)
      - name: Build iOS Simulator app
        run: |
          # Build for iOS Simulator (arm64 for M1/M2 Macs)
          flutter build ios --simulator --debug
          echo "âœ… iOS Simulator build complete"
          ls -la build/ios/iphonesimulator/ || true

      # Also build release for device (no codesign) - useful for reference
      - name: Build iOS Device (no codesign)
        run: flutter build ios --release --no-codesign

      # Create a zip of the simulator app for easier download
      - name: Package iOS Simulator app
        run: |
          cd build/ios/iphonesimulator
          zip -r Runner-Simulator.app.zip Runner.app
          mv Runner-Simulator.app.zip ../../../
          echo "âœ… Packaged iOS Simulator app"

      # Upload iOS Simulator build artifact
      - name: Upload iOS Simulator artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-simulator
          path: Runner-Simulator.app.zip
          retention-days: 30

      # Upload iOS Device build artifact
      - name: Upload iOS Device artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-device
          path: build/ios/iphoneos/Runner.app
          retention-days: 30

  ################################################################################
  # CREATE RELEASE - Create GitHub release with artifacts (auto on every push)
  ################################################################################
  create-release:
    name: Create Release
    needs: [build-android, build-ios]
    runs-on: self-hosted
    # Create release on EVERY successful build (push to main or manual dispatch)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to count releases

      # Download Android APK
      - name: Download Android APK
        uses: actions/download-artifact@v4
        with:
          name: android-apk
          path: ./artifacts

      # Download Android AAB
      - name: Download Android AAB
        uses: actions/download-artifact@v4
        with:
          name: android-aab
          path: ./artifacts

      # Download iOS Simulator build
      - name: Download iOS Simulator build
        uses: actions/download-artifact@v4
        with:
          name: ios-simulator
          path: ./artifacts

      # Determine release version (0.001, 0.002, 0.003, ...)
      - name: Determine release version
        id: release-tag
        run: |
          # Count existing releases to determine next version number
          # Using GitHub API to get release count
          RELEASE_COUNT=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases" | \
            grep -c '"tag_name"' || echo "0")

          # Next version is count + 1, formatted as 0.XXX
          NEXT_NUM=$((RELEASE_COUNT + 1))
          VERSION=$(printf "0.%03d" $NEXT_NUM)

          echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Next release version: v${VERSION}"

      # Create Release
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-tag.outputs.tag }}
          name: Release ${{ steps.release-tag.outputs.version }}
          draft: false
          prerelease: false
          body: |
            ## ðŸš€ Release ${{ steps.release-tag.outputs.version }}

            **Build Type:** ${{ github.event_name == 'workflow_dispatch' && 'Manual' || 'Automatic' }}
            **Branch:** ${{ github.ref_name }}
            **Commit:** ${{ github.sha }}

            ### ðŸ“¦ Artifacts
            - **Android APK**: `app-release.apk` - Ready for direct installation on Android devices
            - **Android AAB**: `app-release.aab` - For Google Play Store (requires signing)
            - **iOS Simulator**: `Runner-Simulator.app.zip` - For running on iOS Simulator (M1/M2 Mac)

            ### ðŸ“± Installation
            **Android:**
            1. Download `app-release.apk`
            2. Enable "Install from unknown sources" on your device
            3. Open the APK file to install

            **iOS Simulator (Mac M1/M2):**
            1. Download `Runner-Simulator.app.zip`
            2. Unzip the file
            3. Open iOS Simulator
            4. Drag `Runner.app` onto the Simulator window

            ### ðŸ“ Changes
            See commit history for details: https://github.com/${{ github.repository }}/commits/${{ github.sha }}

            ### ðŸ”§ Built with
            - Flutter ${{ env.FLUTTER_VERSION }}
            - Java ${{ env.JAVA_VERSION }}
            - llama.cpp (version: see `scripts/llama-version.txt`)

            ### â±ï¸ Build Information
            - Workflow Run: #${{ github.run_number }}
            - Triggered by: @${{ github.actor }}
          files: |
            ./artifacts/app-release.apk
            ./artifacts/app-release.aab
            ./artifacts/Runner-Simulator.app.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Print summary
      - name: Print build summary
        run: |
          echo "## ðŸŽ‰ Build Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Android APK: $(ls -lh ./artifacts/app-release.apk | awk '{print $5}')" >> $GITHUB_STEP_SUMMARY
          echo "- Android AAB: $(ls -lh ./artifacts/app-release.aab | awk '{print $5}')" >> $GITHUB_STEP_SUMMARY
          echo "- iOS Simulator: $(ls -lh ./artifacts/Runner-Simulator.app.zip | awk '{print $5}')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ·ï¸ Release" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ steps.release-tag.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ steps.release-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY

